---
title: "Blood stream infections"
csl: the-american-naturalist.csl
output:
  html_document:
    theme: cerulean
    toc: yes
  pdf_document:
    toc: yes
<!-- bibliography: references.bib -->
editor_options: 
  chunk_output_type: console
---

<!--
IMAGES:
Insert them with: ![alt text](image.png)
You can also resize them if needed: convert image.png -resize 50% image.png
If you want to center the image, go through HTML code:
<div style="text-align:center"><img src ="image.png"/></div>

REFERENCES:
For references: Put all the bibTeX references in the file "references.bib"
in the current folder and cite the references as @key or [@key] in the text.
Uncomment the bibliography field in the above header and put a "References"
title wherever you want to display the reference list.

<style type="text/css">
.main-container {
  max-width: 1370px;
  margin-left: auto;
  margin-right: auto;
}
</style>
-->

```{css horizontal scrolling, echo = FALSE}
pre, code {white-space:pre !important; overflow-x:scroll !important}

html { overflow-x: scroll; }
```


```{r general options, include = FALSE}
knitr::knit_hooks$set(
  margin = function(before, options, envir) {
    if (before) par(mgp = c(1.5, .5, 0), bty = "n", plt = c(.105, .97, .13, .97))
    else NULL
  },
  prompt = function(before, options, envir) {
    options(prompt = if (options$engine %in% c("sh", "bash")) "$ " else "> ")
  })

knitr::opts_chunk$set(cache = FALSE, autodep = TRUE, message = FALSE, warning = FALSE,
                      dev.args = list(pointsize = 11), fig.height = 3.5,
                      fig.width = 4.24725, fig.retina = 2, fig.align = "center")

#options(width = 137)
options(width = 200)
```

## Packages

Installing the required packages:

```{r}
required <- c("dplyr", "lubridate", "magrittr", "purrr", "readxl", "tibble", "tidyr")
to_install <- setdiff(required, row.names(installed.packages()))
if (length(to_install)) install.packages(to_install)
```

Loading `magrittr` for interactive use:

```{r}
library(magrittr)
```

## Accessory functions

The following function replaces `FALSE` surounded by `TRUE` values by `TRUE` in
a logical vector:

```{r}
fill_gaps <- function(x) {
  require(magrittr)
  as.integer(x) %>% # because easier to deal with 1-character encoding
    paste(collapse = "") %>% 
    gsub("101", "111", .)
}
```

Let's try it:

```{r}
fill_gaps(c(TRUE, FALSE, TRUE, TRUE, FALSE, FALSE, TRUE))
```

The following function replaces `111000111100110011` by `111000222200330044`

```{r}
episodes <- function(x) {
  require(magrittr)
  x %<>% 
    strsplit("") %>% 
    unlist() %>% 
    as.integer() %>% 
    rle()
  sel <- which(x$values > 0)
  x$values[sel] <- seq_along(sel)
  inverse.rle(x)
}
```

Let's try it:

```{r}
episodes("111000111100110011")
```

A tuning of the `dplyr::left_join()` function:

```{r}
leftjoin <- function(...) dplyr::left_join(..., by = "PatientNo")
```

A tuning of the `dplyr::bind_rows()` function:

```{r}
bindrows <- function(...) dplyr::bind_rows(..., .id = "PatientNo")
```

## Reading data

The data are in this file:

```{r}
data_file <- "19-8-2019-CTU16HN_Data.xls.xlsx"
```

The list of sheets that we are interested in:

```{r}
sheets <- c("ADM", "AIR", "APAC", "DAILY1n2", "ENR", "FINISH", "FU", "FU_DAY90", "MICBLD")
```

Reading all the sheets of this file and transforming the dates:

```{r warning = FALSE}
data <- sheets %>%
  lapply(readxl::read_excel, path = data_file) %>% 
  lapply(function(x) dplyr::mutate_if(x, function(y) "POSIXct" %in% class(y), as.Date)) %>% 
  setNames(sheets)
```

### Adding the episode variable to MICBLD

In order to be able to add the `episode` variable to `data$MICBLD` we need to
define the following function that computes the `episode` variable **for a given
patient** using the `fill_gaps()` and `episodes()` accessory functions that we
defined above. This episode variable tells, **for a given patient**, whether the
episode is the first one, the second one, etc...

```{r}
compute_episode <- function(x) {
  require(magrittr)
  x %$% 
    dplyr::full_join(data.frame(HAIDate = seq(min(HAIDate), max(HAIDate), 1)), # expanding the dates
                     data.frame(HAIDate = sort(unique(HAIDate)), A = TRUE), "HAIDate") %>%
    assign("tmp1", ., 1) %>% 
    dplyr::mutate(A = tidyr::replace_na(A, FALSE)) %>% 
    purrr::pluck("A") %>% 
    fill_gaps() %>% # episodes are considered as separate if there is more than 1 day between them
    episodes() %>% # give the ID of the episode
    cbind(tmp1, episode = .) %>%
    dplyr::left_join(x, ., "HAIDate") %>% 
    dplyr::select(id, episode)
}
```

Let's try it:

```{r}
data$MICBLD %>% 
  dplyr::filter(PatientNo == "003-510") %>% 
  dplyr::select(PatientNo, HAIDate) %>% 
  dplyr::mutate(id = 13:14) %>% 
  print() %>%
  compute_episode()
```

Adding the `episode` variable to `data$MICBLD`:

```{r}
# •	Episode of BSI: each episode is defined as below
#   	MICBLD.OrganismsNo≥ 1
#   	Date of each episode (MICBLD.HAIDate) was >2 days apart from each others
#     (for one ID, if MICBLD.HAIDate of the episode 1> MICBLD.HAIDate of episode
#     2 + “2 days”, they are considered as 1 episode)
```

In R below. Note that 

```{r}
data$MICBLD %<>% 
  dplyr::mutate(id = dplyr::row_number()) %>% # necessary for the left_join below
  assign("tmp2", ., 1) %>% # to save before the filter for subsequent merging
  dplyr::filter(OrganismsNo > 0) %>% # First condition: MICBLD.OrganismsNo≥ 1
  dplyr::select(id, PatientNo, HAIDate) %>% 
  split(.$PatientNo) %>% # The computation of the episodes is by patient
  lapply(compute_episode) %>% # Second condition: episodes separated by more than 2 days
  dplyr::bind_rows() %>% 
  dplyr::left_join(tmp2, ., "id") %>% 
  dplyr::select(-id)
```

We can see that no patient has more than 2 BSI episodes:

```{r}
table(data$MICBLD$episode)
```

### Recoding some ADM variables into logical

```{r}
data$ADM %<>% 
  dplyr::mutate_at(
    c("Mode", "CongIV", "Seve", "AIDS", "Elective", "Emergency", "Myo", "DiaCo", "DiaDa"),
    function(x) dplyr::na_if(x, "NA") == "Yes")
```

### Exploring the data

Note that some of these data sets have one row per patient whereas other data
sets have more than one row per patient:

```{r}
(nbrow <- sapply(data, function(x) length(unique(table(x$PatientNo)))))
```

The number of rows of each of the data sets:

```{r}
sapply(data, nrow)
```

### Reading the dictionary of variables and levels

```{r}
dictionary <- readxl::read_excel("Copy of CTU16HN_DataDictionary.xlsx", "Category")
```

## Redefining MICBLD and DAILY1n2

The `MICBLD` and `DAILY1n2` data sets have several rows per patient. Here we
compute summaries of these data sets with one row per patient so that they can
easily be merge with the other data sets.

### The MICBLD data set

```{r}
(micbld <- lapply(list(function(x) x %>% # this function should be first
                         dplyr::group_by(PatientNo) %>% 
# •	Patients with BSI: patients with any the first episode of BSI:                         
                         dplyr::summarise(bsi = any(OrganismsNo > 0)),
                       function(x) x %>% 
                         dplyr::filter(episode < 2) %>% # blood collection of first episode
                         dplyr::group_by(PatientNo) %>% 
                         dplyr::summarise(blood_collection = min(HAIDate))),
                  function(f) f(data$MICBLD)) %>% 
   purrr::reduce(leftjoin))
```

### The DAILY1n2 data set

The following function tells, for one data frame of one patient, whether there
are two consecutive dates:

```{r}
two_consecutive <- function(x, name) {
  x %>% 
    dplyr::arrange(VSDate) %>% 
    purrr::pluck("VSDate") %>% 
    diff() %>% 
    `<`(2) %>% 
    any() %>% 
    tibble::enframe(name = NULL, value = name)
}
```

Let's try it:

```{r}
data$DAILY1n2 %>% 
  dplyr::filter(PatientNo == "003-001") %>% 
  dplyr::select(PatientNo, VSDate, CVCCount) %>% 
  print() %>% 
  two_consecutive("name")
```

List of 7 functions (note that for the last 3 of these functions, the `name`
argument is not used but we keep it for interface consistency):

```{r}
lfcts <- list(

# •	Patients at risk of CLBSI: patients with any central line placemen during
#   hospitalization (DAILY1n2.CVCCount ≥1) for at least 2 consecutive days (using
#   DAILY1n2.VSDate and DAILY1n2.VSDate+1):
  clbsi_risk = function(df, name) {
    require(magrittr)
    df %>% 
      split(.$PatientNo) %>% 
      lapply(function(x) x %>% 
        dplyr::filter(CVCCount > 0) %>%
        two_consecutive(name)) %>% 
      bindrows()
  },

# •	Patients at risk of arterial line BSI: patients with any central line placemen
#   during hospitalization (DAILY1n2. Arterial=Yes) for at least 2 consecutive
#   days (using DAILY1n2.VSDate and DAILY1n2.VSDate+1)
  al_bsi_risk = function(df, name) {
    require(magrittr)
    df %>% 
      split(.$PatientNo) %>% 
      lapply(function(x) x %>% 
        dplyr::filter(Arterial == "Yes") %>%
        two_consecutive(name)) %>% 
      bindrows()
  },
  
# •	Patients with CLBSI: 
#   	Patients have a first episode of BSI: as above definition
#   	Catheter was placed for at least 2 consecutive days within 5 days before
#     the date of blood collection of the first BSI episode: 
#     - Define Catheter was placed: DAILY1n2.CVCCount>=1
#     - Define 5 days before the date of blood collection of the first BSI episode:
#       “MICBLD.HAIDate -5” to “MICBLD.HAIDate”
#     - Define at least 2 consecutive days: using DAILY1n2.VSDate
  clbsi = function(df, name) {
    require(magrittr)
    df %>% 
      leftjoin(micbld) %>% 
      split(.$PatientNo) %>% 
      lapply(function(x) x %>% 
               dplyr::filter(CVCCount > 0) %>%
               dplyr::filter(blood_collection - VSDate < 6) %>% 
               two_consecutive(name)) %>% 
      bindrows()
  },

# •	Patients with arterial line BSI
#   	Patients have a first episode of BSI: as above definition
#   	Arterial line was placed for at least 2 consecutive days within 5 days
#     before the date of blood collection of the first BSI episode: 
#     -	Define “Arterial line was placed”: DAILY1n2. Arterial=Yes
#     -	Define 5 days before the date of blood collection of the first BSI
#       episode: “MICBLD.HAIDate -5” to “MICBLD.HAIDate”
#     -	Define at least 2 consecutive days: using DAILY1n2.VSDate
  al_bsi = function(df, name) {
    require(magrittr)
    df %>% 
      leftjoin(micbld) %>% 
      split(.$PatientNo) %>% 
      lapply(function(x) x %>% 
               dplyr::filter(Arterial == "Yes") %>%
               dplyr::filter(blood_collection - VSDate < 6) %>% 
               two_consecutive(name)) %>% 
      bindrows()
  },

# Count number of patients having at least 1 catheter during the ICU stay:
# DAILY1n2.CVCCount>=1 (page 5, line 6)
  had_catheter = function(df, name) {
    require(magrittr)
    df %>% 
      dplyr::group_by(PatientNo) %>% 
      dplyr::summarise(catheter = any(CVCCount > 0)) %>% 
      dplyr::mutate(catheter = tidyr::replace_na(catheter, FALSE))
  },

# Total number of Central line day (page 5, last line)
# Count number of days (DAILY1n2.VSDate) with DAILY1n2.CVCCount>=1. For patients
# with BSI, only count number of days until the date of the first BSI episode
# (DAILY1n2.VSDate= MICBLD.HAIDate) (see next function)
  nb_cl_days = function(df, name) {
    require(magrittr)
    df %>% 
      split(.$PatientNo) %>% 
      lapply(function(x) x %>% 
               dplyr::filter(CVCCount > 0) %>% 
               nrow() %>% 
               tibble::enframe(name = NULL, value = "nb_cl_days")) %>% 
      bindrows()
  },

# For patients with BSI, only count number of days until the date of the first
# BSI episode (DAILY1n2.VSDate= MICBLD.HAIDate)
  nb_days_before_bsi = function(df, name) {
    require(magrittr)
    df %>% 
      leftjoin(micbld) %>%
      dplyr::group_by(PatientNo) %>% 
      dplyr::summarise(nb_days_before_bsi = sum(VSDate < blood_collection))
    },

# Page 6, row 4:
  arterial = function(df, name) {
    require(magrittr)
    df %>%
      dplyr::group_by(PatientNo) %>% 
      dplyr::summarise(arterial = any(Arterial == "Yes"))
  }
)
```

Applying to `data$DAILY1n2`:

```{r}
(daily <- purrr::map2(lfcts, names(lfcts), function(f, x) f(data$DAILY1n2, x)) %>% 
  purrr::reduce(leftjoin))
```

## Defining populations / groups

The code below defines the variables of interest.

```{r}
data2 <- data$FINISH %>%
  dplyr::select(PatientNo, IsCompleted, IsAgree, HosDate, ICUDate) %>% 
  leftjoin(dplyr::select(data$ENR, PatientNo, Age, RandDate, YOB, Sex)) %>%
  leftjoin(dplyr::select(data$ADM, PatientNo, Source, NKQ, HospitalDate, Mode,
                         CongIV, Seve, AIDS, Elective, Emergency, Tetanus,
                         Pneumonia, Sepsis, Septic, CNS, COPD, CVA, Myo, SpOther,
                         DiaCo, DiaDa, CongI_III, Peri, Cere, Deme, Chro, Conn,
                         Peptic, Mild, Hemi, ModeSeve, AnyMa, Meta)) %>%
  leftjoin(dplyr::select(data$AIR, PatientNo, IsTrach)) %>%
  leftjoin(dplyr::select(micbld, -blood_collection)) %>% 
  leftjoin(daily) %>% 
  
# exclude patients not completed and not agreed --------------------------------
# •	All patients: FINISH.IsCompleted = 2 (which means “No, withdrew consent”)
#   then we can only use the data if they permitted use of data up to this point,
#   defined by FINISH.IsAgree = Yes.  (ie exclude completely only if
#   FINISH.IsAgree = No and FINISH.IsCompleted = No, withdrew consent).
  dplyr::filter(!(IsCompleted == 2 & IsAgree != "Yes")) %>% 

# replace NA with FALSE --------------------------------------------------------  
  dplyr::mutate_at(c("bsi", "clbsi_risk", "clbsi", "al_bsi_risk", "al_bsi"), tidyr::replace_na, FALSE) %>% 

  dplyr::mutate(
# define HABSI variable --------------------------------------------------------
# •	Patients at risk of HABSI: patients with hospitalization for at least 2 days:
#   FINISH.HosDate - ADM.HospitalDate>=2
    habsi = tidyr::replace_na(HosDate - HospitalDate > 1, FALSE), # replace NA with FALSE
    
# define hospitals -------------------------------------------------------------
    hospital = dplyr::recode(sub("-.*$", "", PatientNo),
                             `003` = "HTD",
                             `020` = "NHTD",
                             `103` = "BVTV"),

# any tracheostomy -------------------------------------------------------------
# page 3, row 4:
    tracheo = NKQ < 2 | dplyr::na_if(IsTrach, "NA") == "Yes",

# define tracheostomy vs month -------------------------------------------------
# page 3, row 3:
    nkq = c("tracheostomy", "mouth")[NKQ],

# computing age ----------------------------------------------------------------
# maybe we should consider 1st of July instead?
    age = ifelse(is.na(Age), round(as.numeric(RandDate - lubridate::ymd(paste(YOB, "0101"))) / 365), Age),
  
# other pathogens:
    otherpth = ! is.na(SpOther), 

# durations:
    rand2icu = ICUDate - RandDate,
    rand2hos = HosDate - RandDate,
    adm2icu  = ICUDate - HospitalDate,
    adm2hos  = HosDate - HospitalDate,

# patient-days: 
    patdayRand = sum(ICUDate - RandDate),
    patdayHosp = sum(HosDate - RandDate),

# Page 5, last line:
    nb_cl_days = ifelse(bsi, nb_days_before_bsi, nb_cl_days),
  
# sepsis:
    sepsis = Sepsis | Septic,

# Page 6, last line:
    a = arterial & bsi,
) %>% 
  
# selecting variables of interest ----------------------------------------------
  dplyr::select(-IsCompleted, -IsAgree, -HosDate, -Age, -YOB, -SpOther, -IsTrach, -NKQ, -Sepsis, -Septic, -ICUDate, -nb_days_before_bsi) %>% 
  
# Replacing Yes/No by TRUE/FALSE -----------------------------------------------
  dplyr::mutate_at(dplyr::vars(CongI_III, Peri, Cere, Deme, Chro, Conn, Peptic, Mild, Hemi, ModeSeve, AnyMa, Meta), function(x) x == "Yes")

```

**Note:** nothing to worry about the parsing failure. It concerns `NA` in the
`YOB` variable that is not used anyway.

## Charlson scores

Computing and adding the Charlson scores to `data2`:

```{r}
data2 %<>% 
  dplyr::select(PatientNo, Myo, CongI_III, Peri, Cere, Deme, Chro, Conn, Peptic,
                Mild, DiaCo, Hemi, ModeSeve, DiaDa, AnyMa, Mode, Meta, AIDS) %>% 
  dplyr::mutate_all(tidyr::replace_na, FALSE) %>% 
  dplyr::mutate_if(is.logical, as.integer) %>% 
  dplyr::mutate_at(dplyr::vars(Hemi, ModeSeve, DiaDa, AnyMa), function(x) 2 * x) %>% 
  dplyr::mutate_at(dplyr::vars(Meta, AIDS), function(x) 6 * x) %>% 
  dplyr::mutate(Mode         = 3 * Mode,
                charlson     = dplyr::select_if(., is.numeric) %>% rowSums(),
                charlson_cat = cut(charlson, c(-Inf, 0, 2, 4, Inf)) %>% as.character()) %>% 
  dplyr::select(PatientNo, charlson, charlson_cat) %>% 
  leftjoin(data2, .)
```

## APACHE-II scores

The Apache-II Score provides an estimate of ICU mortality based on a number of
laboratory values and patient signs taking both acute and chronic disease into
account.

**Note:** The data used should relate to the 24 hours prior to randomisation and
the worst (highest scoring) recorded values should be used.

This function below computes score functions:

```{r}
make_score_functions <- function(scores, values) {
  function(x) scores[cut(x, c(-Inf, values, +Inf), right = FALSE)]
}
```

The parameters values for the score functions:

```{r}
apache_physio <- list(
  temp = list(
    scores = c(4:0, 1, 3, 4),
    values = c(30, 32, 34, 36, 38.5, 39, 41)),
  bp = list(
    scores = c(4, 2, 0, 2:4),
    values = c(50, 70, 110, 130, 160)),
  hr = list(
    scores = c(4, 3, 2, 0, 2, 3, 4),
    values = c(40, 55, 70, 110, 140, 180)),
  rr = list(
    scores = c(4, 2, 1, 0, 1, 3, 4),
    values = c(6, 10, 25, 35, 50)),
  pao2 = list(
    scores = 4:0,
    values = c(55, 61, 70)),
  aa_gradient = list(
    scores = 0:4,
    values = c(200, 350, 500)),
  ph = list(
    scores = c(4, 3, 2, 0, 1, 3, 4),
    values = c(7.15, 7.25, 7.33, 7.5, 7.6, 7.7)),
  hco3 = list(
    scores = c(4, 3, 2, 0, 1, 3, 4),
    values = c(15, 18, 23, 32, 41, 52)),
  na = list(
    scores = c(4:2, 0:4),
    values = c(111, 120, 130, 150, 155, 160, 180)),
  k = list(
    scores = c(4, 2:0, 1, 3, 4),
    values = c(2.5, 3, 3.5, 5.5, 6, 7)),
  creatinine = list(
    scores = c(2, 0, 2:4),
    values = c(0.6, 1.5, 2, 3.5)),
  hematocrit = list(
    scores = c(4, 2, 0:2, 4),
    values = c(20, 30, 46, 50, 60)),
  wbc = list(
    scores = c(4, 2, 0:2, 4),
    values = c(1, 3, 15, 20, 40)),
  age = list(
    scores = c(0, 2, 3, 5, 6),
    values = c(45, 55, 65, 75)))
```

Let's generate the score functions:

```{r}
score_fcts <- setNames(lapply(apache_physio,
                              function(x) make_score_functions(x$scores, x$values)), 
                       names(apache_physio))
```

Let's see an example:

```{r}
head(score_fcts$temp(data$DAILY1n2$TempMax), 100)
```

Computing and adding the apache scores to `data2`:

```{r}
data2 <- data$APAC %>% 
  dplyr::left_join(dplyr::select(data2, PatientNo, age, RandDate, Mode, CongIV, Seve, AIDS, Elective, Emergency), "PatientNo") %>% 
  dplyr::left_join(dplyr::select(data$DAILY1n2, PatientNo, VSDate, TempMax, TempMin), c("PatientNo", "RandDate" = "VSDate")) %>% 
  dplyr::mutate(a = score_fcts$temp(TempMax),
                b = score_fcts$temp(TempMin),
                temp_score = ifelse(a < b, b, a),
                map_score  = score_fcts$bp((2 * Diastolic + Systolic) / 3),
                a = score_fcts$hr(PuHightest),
                b = score_fcts$hr(PuLowest),
                hr_score = ifelse(a < b, b, a),
                a = score_fcts$rr(ResHightest),
                b = score_fcts$rr(ResLowest),
                rr_score = ifelse(a < b, b, a),
                PaCO2 = ifelse(is.na(PaCO2), HCO3 / (0.03 * 10 ^ (ArterialpH - 6.1)), PaCO2),
                aa_gradient = 713 * FiO2 - PaCO2 / .8 - PaO2,
                a_score = ifelse(is.na(aa_gradient) | FiO2 < .5, score_fcts$pao2(PaO2), score_fcts$aa_gradient(aa_gradient)),
                ph_score = ifelse(is.na(ArterialpH), score_fcts$hco3(HCO3), score_fcts$ph(ArterialpH)),
                na_score = score_fcts$na(Sodium),
                k_score = score_fcts$k(Potassium),
                creatinine_score = score_fcts$creatinine(Creatinine),
                hematocrit_score = score_fcts$hematocrit(Haematocrit),
                wbc_score = score_fcts$wbc(BloodCell),
                gcs_score = 15 - ifelse(GlasgowScore == "Preintubation",
                                        ifelse(is.na(Motor) | is.na(Verbal) | is.na(Eyes) |
                                                 Motor == 0 | Verbal == 0   | Eyes == 0   |
                                                 Motor == 9 | Verbal == 9   | Eyes == 9,
                                               Total,
                                               Motor + Verbal + Eyes),
                                        15),
                age_score = score_fcts$age(age),
                c_score = ifelse(Mode + CongIV + Seve + AIDS < 1,
                                 0,
                                 ifelse(Emergency,
                                        5,
                                        ifelse(Elective, 2, 5)))) %>% 
  dplyr::select(PatientNo, TempMin, TempMax, temp_score, map_score, hr_score, rr_score, a_score, ph_score, na_score, k_score,
                creatinine_score, hematocrit_score, wbc_score, gcs_score, age_score, c_score) %>% 
  dplyr::mutate_all(tidyr::replace_na, 0) %>% 
  dplyr::transmute(PatientNo = PatientNo,
                   apache = temp_score + map_score + hr_score + rr_score + a_score + ph_score + na_score + k_score +
                            creatinine_score + hematocrit_score + wbc_score + gcs_score + age_score + c_score) %>% 
  leftjoin(data2, .)
```

## Table 1: demographics

Some recoding of variables:

```{r}
recoding <- function(df, var) {
  for (i in var)
    df[, i] <- dplyr::recode(as.character(unlist(df[, i])), `TRUE` = i, `FALSE` = paste("no", i))
  df
}
```

```{r}
data3 <- recoding(data2, c("tracheo", "clbsi_risk", "al_bsi_risk", "Tetanus", "Pneumonia", "sepsis",
                           "CNS", "COPD", "CVA", "Myo", "otherpth", "Mode", "catheter"))
```

```{r}
counts <- function(v, g, dt) {
  require(magrittr)
  dt %>% 
    dplyr::mutate(x              = ! .[[v]],
                  characteristic =   .[[g]]) %>%
    dplyr::group_by(characteristic, x) %>% 
    dplyr::tally() %>% 
    dplyr::ungroup() %>%
    dplyr::mutate(x = dplyr::recode(as.character(x), `FALSE` = paste("with", toupper(v)), `TRUE` = paste("without", toupper(v)))) %>% 
    tidyr::pivot_wider(names_from = x, values_from = n) %>% 
    dplyr::mutate(total          = .[[paste("with", toupper(v))]] + .[[paste("without", toupper(v))]],
                  characteristic = paste(g, characteristic)) %>% 
    dplyr::select(1, 4, 3, 2) %>% 
    dplyr::mutate_all(as.character)
}
```

```{r}
counts("habsi", "hospital", data3)
```

```{r}
proportions <- function(v, g, dt) {
  require(magrittr)
  prop <- function(x, n) {
    tmp <- binom.test(x, n)
    paste0(round(tmp$estimate, 2), " (CI: ", paste(round(tmp$conf.int, 2), collapse = "-"), ")")
  }
  dt %>% 
    dplyr::mutate(x = as.character(! .[[v]]),
                  y = .[[g]]) %>%
    dplyr::group_by(x, y) %>% 
    dplyr::summarise(n = n()) %>% 
    dplyr::ungroup() %>% 
    assign("tmp", ., 1) %>% 
    dplyr::group_by(x) %>% 
    dplyr::summarise(t = sum(n)) %>% 
    dplyr::left_join(tmp, ., "x") %>% 
    assign("tmp", ., 1) %>% 
    dplyr::group_by(y) %>% 
    dplyr::summarise(n = sum(n), t = sum(t)) %>% 
    dplyr::mutate(x = "all") %>% 
    dplyr::bind_rows(tmp, .) %>% 
    dplyr::group_by(x, y) %>% 
    dplyr::summarise(out = prop(n, t)) %>% 
    dplyr::ungroup() %>% 
    dplyr::mutate(x = dplyr::recode(as.character(x),
                                    `FALSE` = paste("with", toupper(v)),
                                    `TRUE`  = paste("without", toupper(v)),
                                    all     = "total")) %>% 
    tidyr::pivot_wider(names_from = x, values_from = out) %>% 
    dplyr::rename(characteristic = y) %>% 
    dplyr::mutate(characteristic = paste(g, characteristic)) %>% 
    dplyr::select(1, 2, 4, 3)
}
```

```{r}
proportions("habsi", "Sex", data2)
```

```{r}
ranges <- function(v, g, dt) {
  require(magrittr)
  iqr <- function(x) {
    tmp <- quantile(x, c(.25, .5, .75), na.rm = TRUE)
    paste0(tmp[2], " (IQR: ", tmp[1], "-", tmp[3], ")")
  }
  dt %>% 
    dplyr::mutate(x = ! .[[v]],
                  y = .[[g]]) %>%
    dplyr::group_by(x) %>% 
    dplyr::summarize(y = iqr(y)) %>% 
    dplyr::mutate(x = dplyr::recode(as.character(x),
                                    `FALSE` = paste("with", toupper(v)),
                                    `TRUE` = paste("without", toupper(v)))) %>% 
    tidyr::pivot_wider(names_from = x, values_from = y) %>% 
    dplyr::mutate(characteristic = g,
                  total          = iqr(dt[[g]])) %>% 
    dplyr::select(3, 4, 2, 1)
}
```

```{r}
ranges("habsi", "age", data2)
```

```{r}
# c("habsi", "bsi", "clbsi", "al_bsi")
```

```{r}
dplyr::bind_rows(counts("habsi", "hospital", data3),
                 proportions("habsi", "Sex", data2),
                 ranges("habsi", "age", data2),
                 proportions("habsi", "Source", data2),
                 proportions("habsi", "nkq", data2),
                 proportions("habsi", "tracheo", data2),
                 proportions("habsi", "clbsi_risk", data2),
                 proportions("habsi", "al_bsi_risk", data2),
                 ranges("habsi", "apache", data2),
                 ranges("habsi", "charlson", data2),
                 proportions("habsi", "charlson_cat", data2),
                 counts("habsi", "Tetanus", data3),
                 counts("habsi", "Pneumonia", data3),
                 counts("habsi", "sepsis", data3),
                 counts("habsi", "CNS", data3),
                 counts("habsi", "COPD", data3),
                 counts("habsi", "CVA", data3),
                 counts("habsi", "Myo", data3),
                 counts("habsi", "otherpth", data3)) %>% 
  dplyr::filter(! grepl(" no ", characteristic)) %>%
  dplyr::bind_rows(.,
    counts("habsi", "Mode", data3),
    ranges("habsi", "rand2icu", data2),
    ranges("habsi", "rand2hos", data2),
    ranges("habsi", "adm2icu", data2),
    ranges("habsi", "adm2hos", data2),
    ranges("habsi", "patdayRand", data2),
    ranges("habsi", "patdayHosp", data2)
  ) %>% 
  print(., n = nrow(.))
```

The following function calculates the mean with confidence interval:

```{r}
mean_ci <- function(x) {
  m <- lm(x ~ 1)
  setNames(c(coef(m), confint(m)), c("estimate", "lower", "upper"))
}
```

Let's try it:

```{r}
mean_ci(data2$nb_cl_days)
```

Page 6, row 3:

```{r}
data2 %>% 
  dplyr::select(nb_cl_days) %>%
  assign("tmp", ., 1) %>% 
  split(data2$habsi) %>% 
  c(list(total = tmp)) %>% 
  lapply(function(x) as.data.frame(matrix(mean_ci(unlist(x)), 1))) %>% 
  dplyr::bind_rows(.id = "d") %>% 
  setNames(c("group", "estimate", "lower", "upper"))
```

Page 6, row 4:

```{r}
data$DAILY1n2 %>%
  dplyr::group_by(PatientNo) %>%
  dplyr::summarise(arterial = sum(Arterial == "Yes"))
```

## Page 7

### Total number of Arterial line day

```{r}

```

